# 递归

### 用递归函数和栈逆序一个栈

https://www.nowcoder.com/questionTerminal/1de82c89cc0e43e9aa6ee8243f4dbefd

```c++
#include <bits/stdc++.h>

using namespace std;

// 弹出 stk 底部的元素
int f(stack<int>& stk) {
    int top = stk.top();
    stk.pop();

    if (stk.empty()) {
        return top;
    }

    int bottom = f(stk);
    stk.emplace(top);
    return bottom;
}

void reverseStack(stack<int>& stk) {
    if (stk.size() < 2) {
        return;
    }

    int bottom = f(stk);
    reverseStack(stk);
    stk.emplace(bottom);
}

int main() {
    int N;
    while (cin >> N) {
        stack<int> stk;
        while (N--) {
            int x;
            cin >> x;
            stk.emplace(x);
        }

        reverseStack(stk);

        cout << stk.top();
        stk.pop();
        while (!stk.empty()) {
            cout << ' ' << stk.top();
            stk.pop();
        }
        cout << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

# 动态规划

## 知识点

### 动态规划的步骤

1. 根据可变参数的范围定义 `dp`；
2. 根据递归函数的 base case 对 `dp` 进行初始化，同时注意 `dp` 中有没有无意义的格子；
3. 分析依赖关系并填充 `dp`；

### 什么是好的动态规划函数

1. 一个可变参数的维度越小越好（大部分题目的每个可变参数都是零维的）；
2. 可变参数的个数越少越好；

### 动态规划的优化方法

1. 空间压缩用于优化空间复杂度
2. 斜率优化用于优化时间复杂度

## 题目

### 预测赢家

https://leetcode.cn/problems/predict-the-winner

这个题目如果要改动态规划的话，需要一个表 `fdp` 和一个表 `sdp`，因为每个表记录的是一个递归函数在确定的可变参数下的取值，现在有两个递归函数，所以需要两个表。假设 `L` 表示行，`R` 表示列，因为 `L <= R`，所以两个表的左下部分是不会被使用的（但是对角线是可以使用的）。这题也可以只用一个递归函数，这时改动态规划就只需要一个 `dp` 即可。

递归 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= s(nums, 0, N - 1);
    }

    // 如果我是先手，我能获得的最大分数
    int f(vector<int>& arr, int L, int R) {
        if (L == R) {
            return arr[L];
        }

        // 我拿左端和右端两种情况，取max
        return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
    }

    // 如果我是后手，我能获得的最大分数
    int s(vector<int>& arr, int L, int R) {
        if (L == R) {
            return 0;
        }

        // 这一步是对手决定的，对手肯定是选择一个对我最不利的拿法，所以取min，所以分对手拿左端和右端两种情况
        return min(f(arr, L + 1, R), f(arr, L, R - 1));
    }
};
```

递归 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return score(nums, 0, N - 1) >= 0;
    }

    int score(vector<int>& nums, int L, int R) {
        if (L == R) {
            return nums[L];
        }
        
        return max(nums[L] - score(nums, L + 1, R), nums[R] - score(nums, L, R - 1));
    }
};
```

时间复杂度：$O\left(2^N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
            }
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 3：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                dp[L][R] = max(nums[L] - dp[L + 1][R], nums[R] - dp[L][R - 1]);
            }
        }

        return dp[0][N - 1] >= 0;
    }
};
```

动态规划 4：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                dp[L][R] = max(nums[L] - dp[L + 1][R], nums[R] - dp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return dp[0][N - 1] >= 0;
    }
};:
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

------

动态规划 5（空间压缩）：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N);

        for (int L = N - 1; L >= 0; --L) {
            dp[L] = nums[L];
            for (int R = L + 1; R < N; ++R) {
                dp[R] = max(nums[L] - dp[R], nums[R] - dp[R - 1]);
            }
        }

        return dp[N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

# 数学

### 分数累加（浙大）

题目：
$$
\frac{1}{a}=\frac{1}{n_1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
其中 $n_1$ 至 $n_m$ 单调递增，例如 $a=2,m=2$ 时，$\frac{1}{2}=\frac{1}{3}+\frac{1}{6}$，现给定 $a$ 和 $m$，任意求一组解。

注：假设所有的解都能用 `int` 类型表示。

解答：

令 $n_1=a+1$，则：
$$
\frac{1}{a}=\frac{1}{a+1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}\\
\frac{1}{a\left(a+1\right)}=\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
很明显，这时可以进行迭代求解了。迭代到最后等式右边只有 $n_m$ 这一项：
$$
\frac{1}{a'}=\frac{1}{n_m}
$$
此时 $n_m=a'$。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int a;
    int m;
    while (cin >> a >> m) {
        int nx = a + 1;
        cout << nx;

        for (int i = 2; i < m; ++i) {
            nx = (nx - 1) * nx + 1;
            cout << ' ' << nx;
        }

        nx = (nx - 1) * nx;
        cout << ' ' << nx << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

