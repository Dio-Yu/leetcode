# 回溯

## 题目

### 括号生成

https://leetcode.cn/problems/generate-parentheses

回溯：

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string path;
        vector<string> res;
        backtrack(n, 0, 0, path, res);
        return res;
    }

    // leftNum >= rightNum, leftNum <= n, rightNum <= n
    void backtrack(int n, int leftNum, int rightNum, string& path, vector<string>& res) {
        if (leftNum == n && rightNum == n) {
            res.emplace_back(path);
            return;
        }

        if (leftNum < n) {
            path.push_back('(');
            backtrack(n, leftNum + 1, rightNum, path, res);
            path.pop_back();
        }
        if (leftNum > rightNum) {
            path.push_back(')');
            backtrack(n, leftNum, rightNum + 1, path, res);
            path.pop_back();
        }
    }
};
```

时间复杂度：$O\left(\frac{4^n}{n\sqrt{n}}\right)$，即回溯函数的执行次数（证明略，另外我认为力扣题解的时间复杂度是错的，回溯函数并不是每次都对答案进行了复制）。

空间复杂度：$O\left(n\right)$，即递归层数。

------

暴力递归：

一个合法的括号组合一定符合 $\left(S_1\right)S_2$ 这样的形式，其中 $S_1$ 和 $S_2$ 可以为空。当 $S_1$ 的长度为 $i$ 时（其中 $0\le i<n$），$S_2$ 的长度为 $n-i-1$，在这 $n-1$ 种可能性下穷举所有情况即可。

对于不同的 $i$，不会有重复的答案。证明如下：假设 $\left(S_1\right)S_2$ 中，$S_1$ 有 $i$ 对括号，$\left(S_{1}^{'}\right)S_{2}^{'}$ 中 $S_{1}^{'}$ 有 $i^{'}$ 对括号（其中 $i^{'}>i$），$\left(S_1\right)S_2$ 中 $S_1$ 后面的右括号的下标为 $index$，$\left(S_{1}^{'}\right)S_{2}^{'}$ 中 $S_1^{'}$ 后面的右括号的下标为 $index^{'}$，如果要使 $\left(S_1\right)S_2$ 和 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left[0,index\right]$ 范围上相同，那么 $S_1^{'}$ 需要贡献 $i$ 个左括号和 $i+1$ 个右括号，这时 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 范围上只能贡献 $i^{'}-i$ 个左括号和 $i^{'}-i-1$ 个右括号。因为 $S_{1}^{'}$ 本身就是合法的括号组合且 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left[0,index\right]$ 范围上也是合法的括号组合 ，这就要求 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 也必须是合法的括号组合，但是 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 范围上只能贡献 $i^{'}-i$ 个左括号和 $i^{'}-i-1$ 个右括号，这并不能构成一个合法的括号组合，反证法成立，所以对于不同的 $i$，不会有重复的答案。

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        if (!n) {
            return vector<string>{""};
        }

        vector<string> res;
        for (int i = 0; i < n; ++i) {
            vector<string> leftRes = generateParenthesis(i);
            vector<string> rightRes = generateParenthesis(n - i - 1);
            for (string& left: leftRes) {
                for (string& right: rightRes) {
                    res.emplace_back("(" + left + ")" + right);
                }
            }
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

回溯也可以改成动态规划。

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<vector<string>> dp(n + 1);

        dp[0].emplace_back("");

        for (int n_ = 1; n_ <= n; ++n_) {
            for (int i = 0; i < n_; ++i) {
                vector<string> leftRes = dp[i];
                vector<string> rightRes = dp[n_ - i - 1];
                for (string& left: leftRes) {
                    for (string& right: rightRes) {
                        dp[n_].emplace_back("(" + left + ")" + right);
                    }
                }
            }
        }

        return dp[n];
    }
};
```

时间复杂度：

空间复杂度：

# 递归

## 题目

### 用递归函数和栈逆序一个栈

https://www.nowcoder.com/questionTerminal/1de82c89cc0e43e9aa6ee8243f4dbefd

```c++
#include <bits/stdc++.h>

using namespace std;

// 弹出 stk 底部的元素
int f(stack<int>& stk) {
    int top = stk.top();
    stk.pop();

    if (stk.empty()) {
        return top;
    }

    int bottom = f(stk);
    stk.emplace(top);
    return bottom;
}

void reverseStack(stack<int>& stk) {
    if (stk.size() < 2) {
        return;
    }

    int bottom = f(stk);
    reverseStack(stk);
    stk.emplace(bottom);
}

int main() {
    int N;
    while (cin >> N) {
        stack<int> stk;
        while (N--) {
            int x;
            cin >> x;
            stk.emplace(x);
        }

        reverseStack(stk);

        cout << stk.top();
        stk.pop();
        while (!stk.empty()) {
            cout << ' ' << stk.top();
            stk.pop();
        }
        cout << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

# 动态规划

## 知识点

### 记忆化搜索和动态规划

将记忆化搜索改成动态规划是为了根据动态规划的表结构中的 **依赖关系** 进行空间压缩和斜率优化。

### 动态规划的步骤

1. 根据可变参数的范围定义 `dp`
2. 根据递归函数的 base case 对 `dp` 进行初始化，同时注意 `dp` 中有没有无意义的格子
3. 分析依赖关系并填充 `dp`

### 什么是好的动态规划函数

1. 一个可变参数的维度越小越好（大部分题目的每个可变参数都是零维的）
2. 可变参数的个数越少越好

### 动态规划的优化方法

1. 空间压缩用于优化空间复杂度

   - 例 1：依赖关系如下图中的 g 所示。声明一个一维的 `dp`，其长度是下图中表的列数。假设现在要计算 f，在 f 覆盖掉 a 之前需要用一个临时变量 t 把 a 的值记录下来，后面就可以使用 a（t）、f 和 b 计算 g 了。

     <img src="刷题笔记.assets/image-20230829111240914.png" alt="image-20230829111240914" style="zoom:50%;" />

   - 例 2：依赖关系如下图中的 l 所示。声明 3 个一维的 `dp1`、`dp2` 和 `dp3`，它们的长度都是下图中表的列数。最开始 `dp1`、`dp2` 和 `dp3` 分别代表表中第 0、1 和 2 行的值，在计算表中的第 3 行时，直接根据 `dp2` 和 `dp3` 计算 `dp1` 即可。这个例子说明如果依赖关系不远就可以用空间压缩优化。

     <img src="刷题笔记.assets/image-20230829155213079.png" alt="image-20230829155213079" style="zoom:50%;" />
     
   - 使用真实的表结构进行空间压缩：在进行空间压缩中，在真实的表结构上标注出哪些元素是存在的以及哪些元素被覆盖了，这样不容易出错。例如在这个依赖关系中

     <img src="刷题笔记.assets/image-20230829160948809.png" alt="image-20230829160948809" style="zoom:50%;" />

     ，更新的步骤是这样的（红色表示值被覆盖了）：

     <img src="刷题笔记.assets/image-20230829161105467.png" alt="image-20230829161105467" style="zoom:50%;" />

     <img src="刷题笔记.assets/image-20230829161151158.png" alt="image-20230829161151158" style="zoom:50%;" />

2. 斜率优化用于优化时间复杂度

## 题目

### 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees

暴力递归：

```c++
class Solution {
public:
    int numTrees(int n) {
        if (!n || n == 1) {
            return 1;
        }

        int res = 0;
        for (int i = 1; i - 1 <= n - i; ++i) {
            res += i - 1 < n - i ? (numTrees(i - 1) * numTrees(n - i)) << 1 : numTrees(i - 1) * numTrees(n - i);
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;

        for (int n_ = 2; n_ <= n; ++n_) {
            for (int i = 1; i - 1 <= n_ - i; ++i) {  // 讨论节点 i 为根节点的情况
                dp[n_] += i - 1 < n_ - i ? (dp[i - 1] * dp[n_ - i]) << 1 : dp[i - 1] * dp[n_ - i];
            }
        }

        return dp[n];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

------

卡塔兰数：

```c++
class Solution {
public:
    int numTrees(int n) {
        long long c = 1;
        for (int n_ = 0; n_ < n; ++n_) {
            c = (((n_ << 1) + 1) << 1) * c / (n_ + 2);
        }
        return c;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

------

打表：

```c++
class Solution {
public:
    int numTrees(int n) {
        switch (n) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 3:
                return 5;
            case 4:
                return 14;
            case 5:
                return 42;
            case 6:
                return 132;
            case 7:
                return 429;
            case 8:
                return 1430;
            case 9:
                return 4862;
            case 10:
                return 16796;
            case 11:
                return 58786;
            case 12:
                return 208012;
            case 13:
                return 742900;
            case 14:
                return 2674440;
            case 15:
                return 9694845;
            case 16:
                return 35357670;
            case 17:
                return 129644790;
            case 18:
                return 477638700;
            case 19:
                return 1767263190;
            default:
                return 0;
        }
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

### 打家劫舍

https://leetcode.cn/problems/house-robber

暴力递归：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        return f(nums, 0);
    }

    // i <= N；i - 1 位置（若 i > 0）一定没偷
    int f(vector<int>& nums, int i) {
        int N = nums.size();
        if (i == N - 1) {
            return nums[i];
        } else if (i == N) {
            return 0;
        }

        return max(nums[i] + f(nums, i + 2), f(nums, i + 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N + 1);

        dp[N - 1] = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            dp[i] = max(nums[i] + dp[i + 2], dp[i + 1]);
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();

        int next2 = 0;
        int next1 = nums[N - 1];
        int curr = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            curr = max(nums[i] + next2, next1);
            next2 = next1;
            next1 = curr;
        }

        return curr;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

### 不同路径

https://leetcode.cn/problems/unique-paths

暴力递归：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        return f(m, n, 0, 0);
    }

    // i < m, j < n
    int f(int m, int n, int i, int j) {
        if (i == m - 1 || j == n - 1) {
            return 1;
        }

        return f(m, n, i + 1, j) + f(m, n, i, j + 1);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));

        for (int i = 0; i < m; ++i) {
            dp[i][n - 1] = 1;
        }
        for (int j = 0; j < n - 1; ++j) {
            dp[m - 1][j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }

        return dp[0][0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(mn\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n);

        for (int j = 0; j < n; ++j) {
            dp[j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[j] = dp[j] + dp[j + 1];
            }
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(n\right)$

------

排列组合：

$C_{m+n-2}^{m-1}$ 表示在 $m+n-2$ 步中选 $m-1$ 步向下走，其余的步数向右走。其中：
$$
C_{m+n-2}^{m-1}=\frac{\left(m+n-2\right)!}{\left(m-1\right)!\left(n-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots n}{\left(m-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots m}{\left(n-1\right)!}
$$

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long res = 1;
        for (long long numerator = n, denominator = 1; denominator < m; ++numerator, ++denominator) {
            res = res * numerator / denominator;
        }
        return res;
    }
};
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

### 零钱兑换（无限制）

https://leetcode.cn/problems/gaM7Ch

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int res = INT_MAX;
        for (int currCoinsNum = 0; remain - currCoinsNum * coins[i] >= 0; ++currCoinsNum) {
            int followingCoinsNum = f(coins, i + 1, remain - currCoinsNum * coins[i]);
            if (followingCoinsNum != INT_MAX) {
                res = min(res, currCoinsNum + followingCoinsNum);
            }
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

其中 $A$ 表示 `amount`，下同。

------

动态规划 1：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= amount; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                dp[i][remain] = INT_MAX;
                for (int currCoinsNum = 0; currCoinsNum * coins[i] <= remain; ++currCoinsNum) {
                    int followingCoinsNum = dp[i + 1][remain - currCoinsNum * coins[i]];
                    if (followingCoinsNum != INT_MAX) {
                        dp[i][remain] = min(dp[i][remain], currCoinsNum + followingCoinsNum);
                    }
                }
            }
        }

        return dp[0][amount] == INT_MAX ? -1 : dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA^2\right)$

空间复杂度：$O\left(NA\right)$

------

动态规划 2（空间压缩 + 斜率优化）：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<int> dp(amount + 1);

        for (int remain = 1; remain <= amount; ++remain) {
            dp[remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                if (remain - coins[i] >= 0 && dp[remain - coins[i]] != INT_MAX) {
                    dp[remain] = min(dp[remain], dp[remain - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(A\right)$

### 零钱兑换（有限制）

题目：同 https://leetcode.cn/problems/gaM7Ch，但 `coins` 中可能有重复值且每个值只能用一次。

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int p1Next = remain - coins[i] >= 0 ? f(coins, i + 1, remain - coins[i]) : INT_MAX;
        int p2 = f(coins, i + 1, remain);
        return p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= N; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= N; ++remain) {
                int p1Next = remain - coins[i] >= 0 ? dp[i + 1][remain - coins[i]] : INT_MAX;
                int p2 = dp[i + 1][remain];
                dp[i][remain] = p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
            }
        }
        
        return dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(NA\right)$

### 目标和

https://leetcode.cn/problems/YaVDxD

该题很容易写出暴力递归 1 所示的代码，但是会发现在改动态规划时 `remain` 的范围并不好判断，所以需要将原问题转化成另一个让可变参数的范围容易判断的问题。该题可以这样转化：

记 `nums` 的元素之和为 $S$，在 `nums` 中的元素前面添加正负号后，记所有前面添加符号的元素之和为 $M$，易得 $target=\left(S-M\right)-M$，即 $M=\left(S-target\right)/2$。现在需要在 `nums` 中找出一些元素使得这些元素之和为 $\left(S-target\right)/2$，求有多少种不同的找法。

暴力递归 1：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        return f(nums, 0, target);
    }

    int f(vector<int>& nums, int i, int remain) {
        int N = nums.size();
        if (i == N) {
            return !remain;
        }

        return f(nums, i + 1, remain + nums[i]) + f(nums, i + 1, remain - nums[i]);
    }
};
```

暴力递归 2：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        return S - target < 0 || (S - target) & 1 ? 0 : f(nums, 0, (S - target) >> 1);
    }

    // remain >= 0
    int f(vector<int>& nums, int i, int remain) {
        int N = nums.size();
        if (i == N) {
            return !remain;
        }

        return (remain - nums[i] >= 0 ? f(nums, i + 1, remain - nums[i]) : 0) + f(nums, i + 1, remain);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        if (S - target < 0 || (S - target) & 1) {
            return 0;
        }

        int M = (S - target) >> 1;
        int N = nums.size();
        vector<vector<int>> dp(N + 1, vector<int>(M + 1));

        dp[N][0] = 1;

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = M; remain >= 0; --remain) {
                dp[i][remain] = (remain - nums[i] >= 0 ? dp[i + 1][remain - nums[i]] : 0) + dp[i + 1][remain];
            }
        }

        return dp[0][M];
    }
};
```

时间复杂度：$O\left(NM\right)$

空间复杂度：$O\left(NM\right)$

------

动态规划 2（空间压缩）：

```
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        if (S - target < 0 || (S - target) & 1) {
            return 0;
        }

        int M = (S - target) >> 1;
        int N = nums.size();
        vector<int> dp(M + 1);

        dp[0] = 1;

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = M; remain >= 0; --remain) {
                dp[remain] = (remain - nums[i] >= 0 ? dp[remain - nums[i]] : 0) + dp[remain];
            }
        }

        return dp[M];
    }
};
```

时间复杂度：$O\left(NM\right)$

空间复杂度：$O\left(M\right)$

### 机器人达到指定位置方法数

https://www.nowcoder.com/questionTerminal/54679e44604f44d48d1bcadb1fe6eb61

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

long long f(int N, int M, int K, int P) {
    if (!K) {
        return M == P;
    }

    return ((P > 1 ? f(N, M, K - 1, P - 1) : 0) + (P < N ? f(N, M, K - 1, P + 1) : 0)) % (long long) (1e9 + 7);
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << f(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

long long waysNum(int N, int M, int K, int P) {
    vector<vector<long long>> dp(K + 1, vector<long long>(N + 1));

    dp[0][M] = 1;

    for (int K_ = 1; K_ <= K; ++K_) {
        for (int P_ = 1; P_ <= N; ++P_) {
            dp[K_][P_] = ((P_ > 1 ? dp[K_ - 1][P_ - 1] : 0) + (P_ < N ? dp[K_ - 1][P_ + 1] : 0)) % (long long) (1e9 + 7);
        }
    }

    return dp[K][P];
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << waysNum(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(KN\right)$

空间复杂度：$O\left(KN\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

long long waysNum(int N, int M, int K, int P) {
    vector<long long> dp(N + 1);

    dp[M] = 1;

    for (int K_ = 1; K_ <= K; ++K_) {
        int temp1 = -1;
        int temp2 = -1;
        for (int P_ = 1; P_ <= N; ++P_) {
            temp2 = dp[P_];
            dp[P_] = ((P_ > 1 ? temp1 : 0) + (P_ < N ? dp[P_ + 1] : 0)) % (long long) (1e9 + 7);
            temp1 = temp2;
        }
    }

    return dp[P];
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << waysNum(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(KN\right)$

空间复杂度：$O\left(N\right)$

### 最小路径和

https://leetcode.cn/problems/minimum-path-sum

暴力递归：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        return f(grid, 0, 0);
    }

    int f(vector<vector<int>>& grid, int i, int j) {
        int M = grid.size();
        int N = grid[0].size();
        if (i == M - 1 && j == N - 1) {
            return grid[i][j];
        }

        return grid[i][j] + min(i < M - 1 ? f(grid, i + 1, j) : INT_MAX, j < N - 1 ? f(grid, i, j + 1) : INT_MAX);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int M = grid.size();
        int N = grid[0].size();
        vector<vector<int>> dp(M, vector<int>(N));

        dp[M - 1][N - 1] = grid[M - 1][N - 1];
        for (int i = M - 2; i >= 0; --i) {
            dp[i][N - 1] = grid[i][N - 1] + dp[i + 1][N - 1];
        }
        for (int j = N - 2; j >= 0; --j) {
            dp[M - 1][j] = grid[M - 1][j] + dp[M - 1][j + 1];
        }

        for (int i = M - 2; i >= 0; --i) {
            for (int j = N - 2; j >= 0; --j) {
                dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1]);
            }
        }
        
        return dp[0][0];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(MN\right)$

------

动态规划 2：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int M = grid.size();
        int N = grid[0].size();
        vector<int> dp(N);

        dp[N - 1] = grid[M - 1][N - 1];
        for (int j = N - 2; j >= 0; --j) {
            dp[j] = grid[M - 1][j] + dp[j + 1];
        }

        for (int i = M - 2; i >= 0; --i) {
            dp[N - 1] = grid[i][N - 1] + dp[N - 1];
            for (int j = N - 2; j >= 0; --j) {
                dp[j] = grid[i][j] + min(dp[j], dp[j + 1]);
            }
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(N\right)$

### Bob 的生存概率

https://www.nowcoder.com/questionTerminal/be311584a3d64ee0a7462dbeb79f00f5

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

long long f(int M, int N, int i, int j, int k) {
    if (i < 0 || i > M - 1 || j < 0 || j > N - 1) {
        return 0;
    } else if (!k) {
        return 1;
    }

    return f(M, N, i - 1, j, k - 1) + f(M, N, i + 1, j, k - 1) + f(M, N, i, j - 1, k - 1) + f(M, N, i, j + 1, k - 1);
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = f(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

long long getSurvivalWaysNum(int M, int N, int i, int j, int k) {
    vector<vector<vector<long long>>> dp(M, vector<vector<long long>>(N, vector<long long>(k + 1)));

    for (int i_ = 0; i_ < M; ++i_) {
        for (int j_ = 0; j_ < N; ++j_) {
            dp[i_][j_][0] = 1;
        }
    }

    auto getValue = [&dp](int i_, int j_, int k_) -> long long {
        int M = dp.size();
        int N = dp[0].size();
        return i_ < 0 || i_ > M - 1 || j_ < 0 || j_ > N - 1 ? 0 : dp[i_][j_][k_];
    };
    for (int k_ = 1; k_ <= k; ++k_) {
        for (int i_ = 0; i_ < M; ++i_) {
            for (int j_ = 0; j_ < N; ++j_) {
                dp[i_][j_][k_] = getValue(i_ - 1, j_, k_ - 1) + getValue(i_ + 1, j_, k_ - 1) + getValue(i_, j_ - 1, k_ - 1) + getValue(i_, j_ + 1, k_ - 1);
            }
        }
    }
    return dp[i][j][k];
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = getSurvivalWaysNum(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(MNk\right)$

空间复杂度：$O\left(MNk\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

long long getSurvivalWaysNum(int M, int N, int i, int j, int k) {
    vector<vector<long long>> dp(M, vector<long long>(N, 1));

    for (int k_ = 1; k_ <= k; ++k_) {
        vector<long long> temp1(N);
        vector<long long> temp2(N);
        for (int i_ = 0; i_ < M; ++i_) {
            temp2 = dp[i_];
            for (int j_ = 0; j_ < N; ++j_) {
                dp[i_][j_] = (i_ > 0 ? temp1[j_] : 0) + (i_ < M - 1 ? dp[i_ + 1][j_] : 0) + (j_ > 0 ? temp2[j_ - 1] : 0) + (j_ < N - 1 ? dp[i_][j_ + 1] : 0);
            }
            temp1 = temp2;
        }
    }
    return dp[i][j];
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = getSurvivalWaysNum(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(MNk\right)$

空间复杂度：$O\left(MN\right)$

### 序列

https://noobdream.com/DreamJudge/Issue/page/995

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

// 0 < i <= N
int f(vector<int>& A, int i, int prev) {
    int N = A.size();
    if (i == N) {
        return 0;
    }

    int followingWeight = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        followingWeight = min(followingWeight, abs(A[i] - num) + (num - prev) * (num - prev) + f(A, i + 1, num));
    }
    return followingWeight;
}

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + f(A, 1, num));
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    vector<vector<int>> dp(N + 1, vector<int>(10));

    for (int i = N - 1; i > 0; --i) {
        for (int prev = 0; prev < 10; ++prev) {
            dp[i][prev] = INT_MAX;
            for (int num = 0; num < 10; ++num) {
                dp[i][prev] = min(dp[i][prev], abs(A[i] - num) + (num - prev) * (num - prev) + dp[i + 1][num]);
            }
        }
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + dp[1][num]);
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    vector<int> dp(10);

    for (int i = N - 1; i > 0; --i) {
        vector<int> temp = dp;
        for (int prev = 0; prev < 10; ++prev) {
            dp[prev] = INT_MAX;
            for (int num = 0; num < 10; ++num) {
                dp[prev] = min(dp[prev], abs(A[i] - num) + (num - prev) * (num - prev) + temp[num]);
            }
        }
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + dp[num]);
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

### 预测赢家

https://leetcode.cn/problems/predict-the-winner

这个题目如果要改动态规划的话，需要一个表 `fdp` 和一个表 `sdp`，因为每个表记录的是一个递归函数在确定的可变参数下的取值，现在有两个递归函数，所以需要两个表。假设 `L` 表示行，`R` 表示列，因为 `L <= R`，所以两个表的左下部分是不会被使用的（但是对角线是可以使用的）。

暴力递归 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= s(nums, 0, N - 1);
    }

    // 如果我是先手，我能获得的最大分数
    int f(vector<int>& arr, int L, int R) {
        if (L == R) {
            return arr[L];
        }

        // 我拿左端和右端两种情况，取max
        return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
    }

    // 如果我是后手，我能获得的最大分数
    int s(vector<int>& arr, int L, int R) {
        if (L == R) {
            return 0;
        }

        // 这一步是对手决定的，对手肯定是选择一个对我最不利的拿法，所以取min，所以分对手拿左端和右端两种情况
        return min(f(arr, L + 1, R), f(arr, L, R - 1));
    }
};
```

也可以只用一个递归函数实现。

暴力递归 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= 0;
    }

    // 如果返回的是负数，那么这个负数的绝对值表示对手的得分
    int f(vector<int>& nums, int L, int R) {
        if (L == R) {
            return nums[L];
        }

        return max(nums[L] - f(nums, L + 1, R), nums[R] - f(nums, L, R - 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
            }
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 3：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                dp[L][R] = max(nums[L] - dp[L + 1][R], nums[R] - dp[L][R - 1]);
            }
        }

        return dp[0][N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

------

动态规划 4（空间压缩）：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N);

        for (int L = N - 1; L >= 0; --L) {
            dp[L] = nums[L];
            for (int R = L + 1; R < N; ++R) {
                dp[R] = max(nums[L] - dp[R], nums[R] - dp[R - 1]);
            }
        }

        return dp[N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

# 数学

## 题目

### 分数累加（浙大）

题目：
$$
\frac{1}{a}=\frac{1}{n_1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
其中 $n_1$ 至 $n_m$ 单调递增，例如 $a=2,m=2$ 时，$\frac{1}{2}=\frac{1}{3}+\frac{1}{6}$，现给定 $a$ 和 $m$，任意求一组解。

注：假设所有的解都能用 `int` 类型表示。

解答：

令 $n_1=a+1$，则：
$$
\frac{1}{a}=\frac{1}{a+1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}\\
\frac{1}{a\left(a+1\right)}=\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
很明显，这时可以进行迭代求解了。迭代到最后等式右边只有 $n_m$ 这一项：
$$
\frac{1}{a'}=\frac{1}{n_m}
$$
此时 $n_m=a'$。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int a;
    int m;
    while (cin >> a >> m) {
        int nx = a + 1;
        cout << nx;

        for (int i = 2; i < m; ++i) {
            nx = (nx - 1) * nx + 1;
            cout << ' ' << nx;
        }

        nx = (nx - 1) * nx;
        cout << ' ' << nx << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

