# 递归

## 题目

### 用递归函数和栈逆序一个栈

https://www.nowcoder.com/questionTerminal/1de82c89cc0e43e9aa6ee8243f4dbefd

```c++
#include <bits/stdc++.h>

using namespace std;

// 弹出 stk 底部的元素
int f(stack<int>& stk) {
    int top = stk.top();
    stk.pop();

    if (stk.empty()) {
        return top;
    }

    int bottom = f(stk);
    stk.emplace(top);
    return bottom;
}

void reverseStack(stack<int>& stk) {
    if (stk.size() < 2) {
        return;
    }

    int bottom = f(stk);
    reverseStack(stk);
    stk.emplace(bottom);
}

int main() {
    int N;
    while (cin >> N) {
        stack<int> stk;
        while (N--) {
            int x;
            cin >> x;
            stk.emplace(x);
        }

        reverseStack(stk);

        cout << stk.top();
        stk.pop();
        while (!stk.empty()) {
            cout << ' ' << stk.top();
            stk.pop();
        }
        cout << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

# 动态规划

## 知识点

### 记忆化搜索和动态规划

将记忆化搜索改成动态规划是为了根据动态规划的表结构中的 **依赖关系** 进行空间压缩和斜率优化。

### 动态规划的步骤

1. 根据可变参数的范围定义 `dp`
2. 根据递归函数的 base case 对 `dp` 进行初始化，同时注意 `dp` 中有没有无意义的格子
3. 分析依赖关系并填充 `dp`

### 什么是好的动态规划函数

1. 一个可变参数的维度越小越好（大部分题目的每个可变参数都是零维的）
2. 可变参数的个数越少越好

### 动态规划的优化方法

1. 空间压缩用于优化空间复杂度

   - 例 1：依赖关系如下图中的 g 所示。声明一个一维的 `dp`，其长度是下图中表的列数。假设现在要计算 f，在 f 覆盖掉 a 之前需要用一个临时变量 t 把 a 的值记录下来，后面就可以使用 a（t）、f 和 b 计算 g 了。

     <img src="刷题笔记.assets/image-20230829111240914.png" alt="image-20230829111240914" style="zoom:50%;" />

   - 例 2：依赖关系如下图中的 l 所示。声明 3 个一维的 `dp1`、`dp2` 和 `dp3`，它们的长度都是下图中表的列数。最开始 `dp1`、`dp2` 和 `dp3` 分别代表表中第 0、1 和 2 行的值，在计算表中的第 3 行时，直接根据 `dp2` 和 `dp3` 计算 `dp1` 即可。这个例子说明如果依赖关系不远就可以用空间压缩优化。

     <img src="刷题笔记.assets/image-20230829155213079.png" alt="image-20230829155213079" style="zoom:50%;" />
     
   - 使用真实的表结构进行空间压缩：在进行空间压缩中，在真实的表结构上标注出哪些元素是存在的以及哪些元素被覆盖了，这样不容易出错。例如在这个依赖关系中

     <img src="刷题笔记.assets/image-20230829160948809.png" alt="image-20230829160948809" style="zoom:50%;" />

     ，更新的步骤是这样的（红色表示值被覆盖了）：

     <img src="刷题笔记.assets/image-20230829161105467.png" alt="image-20230829161105467" style="zoom:50%;" />

     <img src="刷题笔记.assets/image-20230829161151158.png" alt="image-20230829161151158" style="zoom:50%;" />

2. 斜率优化用于优化时间复杂度

## 题目

### 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees

暴力递归：

```c++
class Solution {
public:
    int numTrees(int n) {
        if (!n || n == 1) {
            return 1;
        }

        int res = 0;
        for (int i = 1; i - 1 <= n - i; ++i) {
            res += i - 1 < n - i ? (numTrees(i - 1) * numTrees(n - i)) << 1 : numTrees(i - 1) * numTrees(n - i);
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;

        for (int n_ = 2; n_ <= n; ++n_) {
            for (int i = 1; i - 1 <= n_ - i; ++i) {  // 讨论节点 i 为根节点的情况
                dp[n_] += i - 1 < n_ - i ? (dp[i - 1] * dp[n_ - i]) << 1 : dp[i - 1] * dp[n_ - i];
            }
        }

        return dp[n];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

------

卡塔兰数：

```c++
class Solution {
public:
    int numTrees(int n) {
        long long c = 1;
        for (int n_ = 0; n_ < n; ++n_) {
            c = (((n_ << 1) + 1) << 1) * c / (n_ + 2);
        }
        return c;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

------

打表：

```c++
class Solution {
public:
    int numTrees(int n) {
        switch (n) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 3:
                return 5;
            case 4:
                return 14;
            case 5:
                return 42;
            case 6:
                return 132;
            case 7:
                return 429;
            case 8:
                return 1430;
            case 9:
                return 4862;
            case 10:
                return 16796;
            case 11:
                return 58786;
            case 12:
                return 208012;
            case 13:
                return 742900;
            case 14:
                return 2674440;
            case 15:
                return 9694845;
            case 16:
                return 35357670;
            case 17:
                return 129644790;
            case 18:
                return 477638700;
            case 19:
                return 1767263190;
            default:
                return 0;
        }
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

### 打家劫舍

https://leetcode.cn/problems/house-robber

暴力递归：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        return f(nums, 0);
    }

    // i <= N；i - 1 位置（若 i > 0）一定没偷
    int f(vector<int>& nums, int i) {
        int N = nums.size();
        if (i == N - 1) {
            return nums[i];
        } else if (i == N) {
            return 0;
        }

        return max(nums[i] + f(nums, i + 2), f(nums, i + 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N + 1);

        dp[N - 1] = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            dp[i] = max(nums[i] + dp[i + 2], dp[i + 1]);
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();

        int next2 = 0;
        int next1 = nums[N - 1];
        int curr = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            curr = max(nums[i] + next2, next1);
            next2 = next1;
            next1 = curr;
        }

        return curr;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

### 不同路径

https://leetcode.cn/problems/unique-paths

暴力递归：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        return f(m, n, 0, 0);
    }

    // i < m, j < n
    int f(int m, int n, int i, int j) {
        if (i == m - 1 || j == n - 1) {
            return 1;
        }

        return f(m, n, i + 1, j) + f(m, n, i, j + 1);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));

        for (int i = 0; i < m; ++i) {
            dp[i][n - 1] = 1;
        }
        for (int j = 0; j < n - 1; ++j) {
            dp[m - 1][j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }

        return dp[0][0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(mn\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n);

        for (int j = 0; j < n; ++j) {
            dp[j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[j] = dp[j] + dp[j + 1];
            }
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(n\right)$

------

排列组合：

$C_{m+n-2}^{m-1}$ 表示在 $m+n-2$ 步中选 $m-1$ 步向下走，其余的步数向右走。其中：
$$
C_{m+n-2}^{m-1}=\frac{\left(m+n-2\right)!}{\left(m-1\right)!\left(n-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots n}{\left(m-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots m}{\left(n-1\right)!}
$$

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long res = 1;
        for (long long numerator = n, denominator = 1; denominator < m; ++numerator, ++denominator) {
            res = res * numerator / denominator;
        }
        return res;
    }
};
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

### 零钱兑换（无限制）

https://leetcode.cn/problems/gaM7Ch

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int res = INT_MAX;
        for (int currCoinsNum = 0; remain - currCoinsNum * coins[i] >= 0; ++currCoinsNum) {
            int followingCoinsNum = f(coins, i + 1, remain - currCoinsNum * coins[i]);
            if (followingCoinsNum != INT_MAX) {
                res = min(res, currCoinsNum + followingCoinsNum);
            }
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

其中 $A$ 表示 `amount`，下同。

------

动态规划 1：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= amount; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                dp[i][remain] = INT_MAX;
                for (int currCoinsNum = 0; currCoinsNum * coins[i] <= remain; ++currCoinsNum) {
                    int followingCoinsNum = dp[i + 1][remain - currCoinsNum * coins[i]];
                    if (followingCoinsNum != INT_MAX) {
                        dp[i][remain] = min(dp[i][remain], currCoinsNum + followingCoinsNum);
                    }
                }
            }
        }

        return dp[0][amount] == INT_MAX ? -1 : dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA^2\right)$

空间复杂度：$O\left(NA\right)$

------

动态规划 2（空间压缩 + 斜率优化）：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<int> dp(amount + 1);

        for (int remain = 1; remain <= amount; ++remain) {
            dp[remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                if (remain - coins[i] >= 0 && dp[remain - coins[i]] != INT_MAX) {
                    dp[remain] = min(dp[remain], dp[remain - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(A\right)$

### 零钱兑换（有限制）

题目：同 https://leetcode.cn/problems/gaM7Ch，但 `coins` 中可能有重复值且每个值只能用一次。

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int p1Next = remain - coins[i] >= 0 ? f(coins, i + 1, remain - coins[i]) : INT_MAX;
        int p2 = f(coins, i + 1, remain);
        return p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= N; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= N; ++remain) {
                int p1Next = remain - coins[i] >= 0 ? dp[i + 1][remain - coins[i]] : INT_MAX;
                int p2 = dp[i + 1][remain];
                dp[i][remain] = p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
            }
        }
        
        return dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(NA\right)$

### 机器人达到指定位置方法数

https://www.nowcoder.com/questionTerminal/54679e44604f44d48d1bcadb1fe6eb61

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

long long f(int N, int M, int K, int P) {
    if (!K) {
        return M == P;
    }

    return ((P > 1 ? f(N, M, K - 1, P - 1) : 0) + (P < N ? f(N, M, K - 1, P + 1) : 0)) % (long long) (1e9 + 7);
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << f(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

long long waysNum(int N, int M, int K, int P) {
    vector<vector<long long>> dp(K + 1, vector<long long>(N + 1));

    dp[0][M] = 1;

    for (int K_ = 1; K_ <= K; ++K_) {
        for (int P_ = 1; P_ <= N; ++P_) {
            dp[K_][P_] = ((P_ > 1 ? dp[K_ - 1][P_ - 1] : 0) + (P_ < N ? dp[K_ - 1][P_ + 1] : 0)) % (long long) (1e9 + 7);
        }
    }

    return dp[K][P];
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << waysNum(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(KN\right)$

空间复杂度：$O\left(KN\right)$

------

动态规划 2（空间压缩）：

```c++
```



### 预测赢家

https://leetcode.cn/problems/predict-the-winner

这个题目如果要改动态规划的话，需要一个表 `fdp` 和一个表 `sdp`，因为每个表记录的是一个递归函数在确定的可变参数下的取值，现在有两个递归函数，所以需要两个表。假设 `L` 表示行，`R` 表示列，因为 `L <= R`，所以两个表的左下部分是不会被使用的（但是对角线是可以使用的）。

暴力递归 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= s(nums, 0, N - 1);
    }

    // 如果我是先手，我能获得的最大分数
    int f(vector<int>& arr, int L, int R) {
        if (L == R) {
            return arr[L];
        }

        // 我拿左端和右端两种情况，取max
        return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
    }

    // 如果我是后手，我能获得的最大分数
    int s(vector<int>& arr, int L, int R) {
        if (L == R) {
            return 0;
        }

        // 这一步是对手决定的，对手肯定是选择一个对我最不利的拿法，所以取min，所以分对手拿左端和右端两种情况
        return min(f(arr, L + 1, R), f(arr, L, R - 1));
    }
};
```

也可以只用一个递归函数实现。

暴力递归 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= 0;
    }

    // 如果返回的是负数，那么这个负数的绝对值表示对手的得分
    int f(vector<int>& nums, int L, int R) {
        if (L == R) {
            return nums[L];
        }

        return max(nums[L] - f(nums, L + 1, R), nums[R] - f(nums, L, R - 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
            }
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 3：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                dp[L][R] = max(nums[L] - dp[L + 1][R], nums[R] - dp[L][R - 1]);
            }
        }

        return dp[0][N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

------

动态规划 4（空间压缩）：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N);

        for (int L = N - 1; L >= 0; --L) {
            dp[L] = nums[L];
            for (int R = L + 1; R < N; ++R) {
                dp[R] = max(nums[L] - dp[R], nums[R] - dp[R - 1]);
            }
        }

        return dp[N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

# 数学

## 题目

### 分数累加（浙大）

题目：
$$
\frac{1}{a}=\frac{1}{n_1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
其中 $n_1$ 至 $n_m$ 单调递增，例如 $a=2,m=2$ 时，$\frac{1}{2}=\frac{1}{3}+\frac{1}{6}$，现给定 $a$ 和 $m$，任意求一组解。

注：假设所有的解都能用 `int` 类型表示。

解答：

令 $n_1=a+1$，则：
$$
\frac{1}{a}=\frac{1}{a+1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}\\
\frac{1}{a\left(a+1\right)}=\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
很明显，这时可以进行迭代求解了。迭代到最后等式右边只有 $n_m$ 这一项：
$$
\frac{1}{a'}=\frac{1}{n_m}
$$
此时 $n_m=a'$。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int a;
    int m;
    while (cin >> a >> m) {
        int nx = a + 1;
        cout << nx;

        for (int i = 2; i < m; ++i) {
            nx = (nx - 1) * nx + 1;
            cout << ' ' << nx;
        }

        nx = (nx - 1) * nx;
        cout << ' ' << nx << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

