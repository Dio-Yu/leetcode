# 模拟

## 题目

### 螺旋矩阵

https://leetcode.cn/problems/spiral-matrix

不要关注局部位置怎么变，应该设计宏观调度过程。设计一个 `getFrame` 函数，接收左上点的坐标，打印出一个边框，主函数不断调用 `getFrame` 函数即可。

模拟：

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int M = matrix.size();
        int N = matrix[0].size();
        vector<int> res(M * N);
        for (int start = 0; start < ((min(M, N) + 1) >> 1); ++start) {
            getFrame(matrix, start, res);
        }
        return res;
    }

    void getFrame(vector<vector<int>>& matrix, int start, vector<int>& res) {
        int M = matrix.size();
        int N = matrix[0].size();
        int end1 = M - 1 - start;
        int end2 = N - 1 - start;
        int index = 2 * start * (M + N - 2 * start);
        if (start == end1) {
            for (int j = start; j <= end2; j++) {
                res[index++] = matrix[start][j];
            }
        } else if (start == end2) {
            for (int i = start; i <= end1; i++) {
                res[index++] = matrix[i][start];
            }
        } else {
            for (int j = start; j < end2; j++) {
                res[index++] = matrix[start][j];
            }
            for (int i = start; i < end1; i++) {
                res[index++] = matrix[i][end2];
            }
            for (int j = end2; j > start; j--) {
                res[index++] = matrix[end1][j];
            }
            for (int i = end1; i > start; i--) {
                res[index++] = matrix[i][start];
            }
        }
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(1\right)$

### 旋转图像

https://leetcode.cn/problems/rotate-image

模拟 1：

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int N = matrix.size();
        int timesRotate = N >> 1;
        for (int start = 0; start < timesRotate; ++start) {
            rotateFrame(matrix, start);
        }
    }

    void rotateFrame(vector<vector<int>>& matrix, int start) {
        int N = matrix.size();
        int end = N - 1 - start;
        for (int i = 0; i < end - start; ++i) {
            int temp = matrix[start][start + i];
            matrix[start][start + i] = matrix[end - i][start];
            matrix[end - i][start] = matrix[end][end - i];
            matrix[end][end - i] = matrix[start + i][end];
            matrix[start + i][end] = temp;
        }
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(1\right)$

------

模拟 2：

先沿水平方向翻转再沿主对角线翻转。即 `M[i][j] -> M[N - 1 - i][j] -> M[j][N - 1 - i]`，`M[i][j] -> M[j][N - 1 - i]` 就是顺时针旋转 90° 的结果。

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int N = matrix.size();
        for (int i = 0; i < (N >> 1); ++i) {
            for (int j = 0; j < N; ++j) {
                swap(matrix[i][j], matrix[N - 1 - i][j]);
            }
        }
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(1\right)$

### 汉明距离

https://leetcode.cn/problems/hamming-distance

模拟 1：

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int xor_ = x ^ y;
        int res = 0;
        while (xor_) {
            res += xor_ & 1;
            xor_ >>= 1;
        }
        return res;
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

------

模拟 2（内置函数）：

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        return __builtin_popcount(x ^ y);
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

------

模拟 3（Brian Kernighan 算法）：

进行 `xor_ &= xor_ - 1` 这个操作之后，`xor_` 最右侧的 1 变成了 0。

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int xor_ = x ^ y;
        int res = 0;
        while (xor_) {
            xor_ &= xor_ - 1;
            ++res;
        }
        return res;
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

### 矩阵置零

https://leetcode.cn/problems/set-matrix-zeroes

模拟 1：

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int M = matrix.size();
        int N = matrix[0].size();
        vector<bool> rows(M);
        vector<bool> cols(N);

        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (!matrix[i][j]) {
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }

        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (rows[i] || cols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(M+N\right)$

------

模拟 2：

使用 `row0` 和 `col0` 这两个变量记录第 0 行和第 0 列上是否有 0，然后使用第 0 行和第 0 列的空间（利用已有数据结构的空间）记录第 `i` 行和第 `j` 列是否需要置零。

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int M = matrix.size();
        int N = matrix[0].size();
        bool row0 = false;
        bool col0 = false;

        for (int i = 0; i < M; ++i) {
            if (!matrix[i][0]) {
                col0 = true;
                break;
            }
        }
        for (int j = 0; j < N; ++j) {
            if (!matrix[0][j]) {
                row0 = true;
                break;
            }
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                if (!matrix[i][j]) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                if (!matrix[0][j] || !matrix[i][0]) {
                    matrix[i][j] = 0;
                }
            }
        }

        if (row0) {
            for (int j = 0; j < N; ++j) {
                matrix[0][j] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < M; ++i) {
                matrix[i][0] = 0;
            }
        }
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(1\right)$

------

模拟 3：

可以再节省 `row0` 这个变量，用 `matrix[0][0]` 来表示第 0 行元素是否需要置零。

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int M = matrix.size();
        int N = matrix[0].size();
        bool col0 = false;

        for (int i = 0; i < M; ++i) {
            if (!matrix[i][0]) {
                col0 = true;
                break;
            }
        }
        for (int j = 0; j < N; ++j) {
            if (!matrix[0][j]) {
                matrix[0][0] = 0;
                break;
            }
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                if (!matrix[i][j]) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                if (!matrix[0][j] || !matrix[i][0]) {
                    matrix[i][j] = 0;
                }
            }
        }

        if (!matrix[0][0]) {
            for (int j = 0; j < N; ++j) {
                matrix[0][j] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < M; ++i) {
                matrix[i][0] = 0;
            }
        }
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(1\right)$

# 二分查找

## 题目

https://leetcode.cn/problems/search-a-2d-matrix

二分查找 1：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int M = matrix.size();
        int N = matrix[0].size();
        int left = 0;
        int right = M * N - 1;
        while (left <= right) {
            int middle = left + ((right - left) >> 1);
            int i = middle / N;
            int j = middle % N;
            if (matrix[i][j] < target) {
                left = middle + 1;
            } else if (matrix[i][j] > target) {
                right = middle - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```

时间复杂度：$O\left(\log{MN}\right)$

空间复杂度：$O\left(1\right)$

------

二分查找 2：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        vector<vector<int>>::iterator it = upper_bound(matrix.begin(), matrix.end(), target, [](const int& target, const vector<int>& row) -> bool { return target < row[0]; });
        if (it == matrix.begin()) {
            return false;
        }
        --it;
        return binary_search(it->begin(), it->end(), target);
    }
};
```

时间复杂度：$O\left(\log{M}+\log{N}\right)=O\left(\log{MN}\right)$

空间复杂度：$O\left(1\right)$

# 回溯

## 题目

### 括号生成

https://leetcode.cn/problems/generate-parentheses

回溯：

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        string path;
        vector<string> res;
        backtrack(n, 0, 0, path, res);
        return res;
    }

    // leftNum >= rightNum, leftNum <= n, rightNum <= n
    void backtrack(int n, int leftNum, int rightNum, string& path, vector<string>& res) {
        if (leftNum == n && rightNum == n) {
            res.emplace_back(path);
            return;
        }

        if (leftNum < n) {
            path.push_back('(');
            backtrack(n, leftNum + 1, rightNum, path, res);
            path.pop_back();
        }
        if (leftNum > rightNum) {
            path.push_back(')');
            backtrack(n, leftNum, rightNum + 1, path, res);
            path.pop_back();
        }
    }
};
```

时间复杂度：$O\left(\frac{4^n}{n\sqrt{n}}\right)$，即回溯函数的执行次数（证明略，另外我认为力扣题解的时间复杂度是错的，回溯函数并不是每次都对答案进行了复制）。

空间复杂度：$O\left(n\right)$，即递归层数。

------

暴力递归：

一个合法的括号组合一定符合 $\left(S_1\right)S_2$ 这样的形式，其中 $S_1$ 和 $S_2$ 可以为空。当 $S_1$ 的长度为 $i$ 时（其中 $0\le i<n$），$S_2$ 的长度为 $n-i-1$，在这 $n-1$ 种可能性下穷举所有情况即可。

对于不同的 $i$，不会有重复的答案。证明如下：假设 $\left(S_1\right)S_2$ 中，$S_1$ 有 $i$ 对括号，$\left(S_{1}^{'}\right)S_{2}^{'}$ 中 $S_{1}^{'}$ 有 $i^{'}$ 对括号（其中 $i^{'}>i$），$\left(S_1\right)S_2$ 中 $S_1$ 后面的右括号的下标为 $index$，$\left(S_{1}^{'}\right)S_{2}^{'}$ 中 $S_1^{'}$ 后面的右括号的下标为 $index^{'}$，如果要使 $\left(S_1\right)S_2$ 和 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left[0,index\right]$ 范围上相同，那么 $S_1^{'}$ 需要贡献 $i$ 个左括号和 $i+1$ 个右括号，这时 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 范围上只能贡献 $i^{'}-i$ 个左括号和 $i^{'}-i-1$ 个右括号。因为 $S_{1}^{'}$ 本身就是合法的括号组合且 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left[0,index\right]$ 范围上也是合法的括号组合 ，这就要求 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 也必须是合法的括号组合，但是 $\left(S_{1}^{'}\right)S_{2}^{'}$ 在 $\left(index,index^{'}\right)$ 范围上只能贡献 $i^{'}-i$ 个左括号和 $i^{'}-i-1$ 个右括号，这并不能构成一个合法的括号组合，反证法成立，所以对于不同的 $i$，不会有重复的答案。

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        if (!n) {
            return vector<string>{""};
        }

        vector<string> res;
        for (int i = 0; i < n; ++i) {
            vector<string> leftRes = generateParenthesis(i);
            vector<string> rightRes = generateParenthesis(n - i - 1);
            for (string& left: leftRes) {
                for (string& right: rightRes) {
                    res.emplace_back("(" + left + ")" + right);
                }
            }
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

回溯也可以改成动态规划。

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<vector<string>> dp(n + 1);

        dp[0].emplace_back("");

        for (int n_ = 1; n_ <= n; ++n_) {
            for (int i = 0; i < n_; ++i) {
                vector<string> leftRes = dp[i];
                vector<string> rightRes = dp[n_ - i - 1];
                for (string& left: leftRes) {
                    for (string& right: rightRes) {
                        dp[n_].emplace_back("(" + left + ")" + right);
                    }
                }
            }
        }

        return dp[n];
    }
};
```

时间复杂度：

空间复杂度：

# 递归

## 题目

### 汉诺塔问题

https://leetcode.cn/problems/hanota-lcci

```c++
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        int N = A.size();
        f(A, B, C, N);
    }

    // 把 A 最上面的 n 个圆盘移动到 C 上，保证 B 是空的且 C 上的圆盘（若有）都比 A 上的圆盘大
    void f(vector<int>& A, vector<int>& B, vector<int>& C, int n) {
        if (n == 1) {
            C.emplace_back(A.back());
            A.pop_back();
            return;
        }

        f(A, C, B, n - 1);
        C.emplace_back(A.back());
        A.pop_back();
        f(B, A, C, n - 1);
    }
};
```

时间复杂度：

空间复杂度：

### 用递归函数和栈逆序一个栈

https://www.nowcoder.com/questionTerminal/1de82c89cc0e43e9aa6ee8243f4dbefd

```c++
#include <bits/stdc++.h>

using namespace std;

// 弹出 stk 底部的元素
int f(stack<int>& stk) {
    int top = stk.top();
    stk.pop();

    if (stk.empty()) {
        return top;
    }

    int bottom = f(stk);
    stk.emplace(top);
    return bottom;
}

void reverseStack(stack<int>& stk) {
    if (stk.size() < 2) {
        return;
    }

    int bottom = f(stk);
    reverseStack(stk);
    stk.emplace(bottom);
}

int main() {
    int N;
    while (cin >> N) {
        stack<int> stk;
        while (N--) {
            int x;
            cin >> x;
            stk.emplace(x);
        }

        reverseStack(stk);

        cout << stk.top();
        stk.pop();
        while (!stk.empty()) {
            cout << ' ' << stk.top();
            stk.pop();
        }
        cout << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

# 动态规划

## 知识点

### 记忆化搜索和动态规划

将记忆化搜索改成动态规划是为了根据动态规划的表结构中的 **依赖关系** 进行空间压缩和斜率优化。

### 动态规划的步骤

1. 根据可变参数的范围定义 `dp`
2. 根据递归函数的 base case 对 `dp` 进行初始化，同时注意 `dp` 中有没有无意义的格子
3. 分析依赖关系并填充 `dp`

### 什么是好的动态规划函数

1. 一个可变参数的维度越小越好（大部分题目的每个可变参数都是零维的）
2. 可变参数的个数越少越好

### 动态规划的优化方法

1. 空间压缩用于优化空间复杂度

   - 例 1：依赖关系如下图中的 g 所示。声明一个一维的 `dp`，其长度是下图中表的列数。假设现在要计算 f，在 f 覆盖掉 a 之前需要用一个临时变量 t 把 a 的值记录下来，后面就可以使用 a（t）、f 和 b 计算 g 了。

     <img src="刷题笔记.assets/image-20230829111240914.png" alt="image-20230829111240914" style="zoom:50%;" />

   - 例 2：依赖关系如下图中的 l 所示。声明 3 个一维的 `dp1`、`dp2` 和 `dp3`，它们的长度都是下图中表的列数。最开始 `dp1`、`dp2` 和 `dp3` 分别代表表中第 0、1 和 2 行的值，在计算表中的第 3 行时，直接根据 `dp2` 和 `dp3` 计算 `dp1` 即可。这个例子说明如果依赖关系不远就可以用空间压缩优化。

     <img src="刷题笔记.assets/image-20230829155213079.png" alt="image-20230829155213079" style="zoom:50%;" />
     
   - 使用真实的表结构进行空间压缩：在进行空间压缩中，在真实的表结构上标注出哪些元素是存在的以及哪些元素被覆盖了，这样不容易出错。例如在这个依赖关系中

     <img src="刷题笔记.assets/image-20230829160948809.png" alt="image-20230829160948809" style="zoom:50%;" />

     ，更新的步骤是这样的（红色表示值被覆盖了）：

     <img src="刷题笔记.assets/image-20230829161105467.png" alt="image-20230829161105467" style="zoom:50%;" />

     <img src="刷题笔记.assets/image-20230829161151158.png" alt="image-20230829161151158" style="zoom:50%;" />

2. 斜率优化用于优化时间复杂度

## 题目

### 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees

暴力递归：

```c++
class Solution {
public:
    int numTrees(int n) {
        if (!n || n == 1) {
            return 1;
        }

        int res = 0;
        for (int i = 1; i - 1 <= n - i; ++i) {
            res += i - 1 < n - i ? (numTrees(i - 1) * numTrees(n - i)) << 1 : numTrees(i - 1) * numTrees(n - i);
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;

        for (int n_ = 2; n_ <= n; ++n_) {
            for (int i = 1; i - 1 <= n_ - i; ++i) {  // 讨论节点 i 为根节点的情况
                dp[n_] += i - 1 < n_ - i ? (dp[i - 1] * dp[n_ - i]) << 1 : dp[i - 1] * dp[n_ - i];
            }
        }

        return dp[n];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

------

卡塔兰数：

```c++
class Solution {
public:
    int numTrees(int n) {
        long long c = 1;
        for (int n_ = 0; n_ < n; ++n_) {
            c = (((n_ << 1) + 1) << 1) * c / (n_ + 2);
        }
        return c;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

------

打表：

```c++
class Solution {
public:
    int numTrees(int n) {
        switch (n) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 3:
                return 5;
            case 4:
                return 14;
            case 5:
                return 42;
            case 6:
                return 132;
            case 7:
                return 429;
            case 8:
                return 1430;
            case 9:
                return 4862;
            case 10:
                return 16796;
            case 11:
                return 58786;
            case 12:
                return 208012;
            case 13:
                return 742900;
            case 14:
                return 2674440;
            case 15:
                return 9694845;
            case 16:
                return 35357670;
            case 17:
                return 129644790;
            case 18:
                return 477638700;
            case 19:
                return 1767263190;
            default:
                return 0;
        }
    }
};
```

时间复杂度：$O\left(1\right)$

空间复杂度：$O\left(1\right)$

### 打家劫舍

https://leetcode.cn/problems/house-robber

暴力递归：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        return f(nums, 0);
    }

    // i <= N；i - 1 位置（若 i > 0）一定没偷
    int f(vector<int>& nums, int i) {
        int N = nums.size();
        if (i == N - 1) {
            return nums[i];
        } else if (i == N) {
            return 0;
        }

        return max(nums[i] + f(nums, i + 2), f(nums, i + 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N + 1);

        dp[N - 1] = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            dp[i] = max(nums[i] + dp[i + 2], dp[i + 1]);
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();

        int next2 = 0;
        int next1 = nums[N - 1];
        int curr = nums[N - 1];

        for (int i = N - 2; i >= 0; --i) {
            curr = max(nums[i] + next2, next1);
            next2 = next1;
            next1 = curr;
        }

        return curr;
    }
};
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

### 裂开的方法数

给定一个正数 `n`，求 `n` 的裂开方法数。规定：后面的数不能比前面的数小 。比如 4 的裂开方法有：1 + 1 + 1 + 1、1 + 1 + 2、1 + 3、2 + 2、4，共 5 种，所以返回 5。

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

int f(int prev, int rest) {
    if (!rest) {
        return 1;
    }
    if (prev > rest) {
        return 0;
    }

    int res = 0;
    for (int curr = prev; curr <= rest; ++curr) {
        res += f(curr, rest - curr);
    }
    return res;
}

int splitWaysNum(int n) {
    return f(1, n);
}

int main() {
    int n;
    while (cin >> n) {
        cout << splitWaysNum(n) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

int splitWaysNum(int n) {
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    for (int prev = 1; prev <= n; ++prev) {
        dp[prev][0] = 1;
    }

    for (int prev = n; prev > 0; --prev) {
        for (int rest = prev; rest <= n; ++rest) {
            for (int curr = prev; curr <= rest; ++curr) {
                dp[prev][rest] += dp[curr][rest - curr];
            }
        }
    }

    return dp[1][n];
}

int main() {
    int n;
    while (cin >> n) {
        cout << splitWaysNum(n) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(n^3\right)$

空间复杂度：$O\left(n^2\right)$

------

动态规划 2（斜率优化）：

```c++
#include <bits/stdc++.h>

using namespace std;

int splitWaysNum(int n) {
    vector<vector<int>> dp(n + 1, vector<int>(n + 1));

    for (int prev = 1; prev <= n; ++prev) {
        dp[prev][0] = 1;
    }

    dp[n][n] = 1;
    for (int prev = n - 1; prev > 0; --prev) {
        for (int rest = prev; rest <= n; ++rest) {
            dp[prev][rest] = dp[prev + 1][rest] + dp[prev][rest - prev];
        }
    }

    return dp[1][n];
}

int main() {
    int n;
    while (cin >> n) {
        cout << splitWaysNum(n) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(n^2\right)$

空间复杂度：$O\left(n^2\right)$

------

动态规划 3（斜率优化 + 空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

int splitWaysNum(int n) {
    vector<int> dp(n + 1);

    dp[0] = 1;

    dp[n] = 1;
    for (int prev = n - 1; prev > 0; --prev) {
        for (int rest = prev; rest <= n; ++rest) {
            dp[rest] += dp[rest - prev];
        }
    }

    return dp[n];
}

int main() {
    int n;
    while (cin >> n) {
        cout << splitWaysNum(n) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(n^2\right)$

空间复杂度：$O\left(n\right)$

### 不同路径

https://leetcode.cn/problems/unique-paths

暴力递归：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        return f(m, n, 0, 0);
    }

    // i < m, j < n
    int f(int m, int n, int i, int j) {
        if (i == m - 1 || j == n - 1) {
            return 1;
        }

        return f(m, n, i + 1, j) + f(m, n, i, j + 1);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));

        for (int i = 0; i < m; ++i) {
            dp[i][n - 1] = 1;
        }
        for (int j = 0; j < n - 1; ++j) {
            dp[m - 1][j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
            }
        }

        return dp[0][0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(mn\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n);

        for (int j = 0; j < n; ++j) {
            dp[j] = 1;
        }

        for (int i = m - 2; i >= 0; --i) {
            for (int j = n - 2; j >= 0; --j) {
                dp[j] = dp[j] + dp[j + 1];
            }
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(mn\right)$

空间复杂度：$O\left(n\right)$

------

排列组合：

$C_{m+n-2}^{m-1}$ 表示在 $m+n-2$ 步中选 $m-1$ 步向下走，其余的步数向右走。其中：
$$
C_{m+n-2}^{m-1}=\frac{\left(m+n-2\right)!}{\left(m-1\right)!\left(n-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots n}{\left(m-1\right)!}=\frac{\left(m+n-2\right)\left(m+n-3\right)\cdots m}{\left(n-1\right)!}
$$

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long res = 1;
        for (long long numerator = n, denominator = 1; denominator < m; ++numerator, ++denominator) {
            res = res * numerator / denominator;
        }
        return res;
    }
};
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

### 零钱兑换（无限制）

https://leetcode.cn/problems/gaM7Ch

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int res = INT_MAX;
        for (int currCoinsNum = 0; remain - currCoinsNum * coins[i] >= 0; ++currCoinsNum) {
            int followingCoinsNum = f(coins, i + 1, remain - currCoinsNum * coins[i]);
            if (followingCoinsNum != INT_MAX) {
                res = min(res, currCoinsNum + followingCoinsNum);
            }
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

其中 $A$ 表示 `amount`，下同。

------

动态规划 1：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= amount; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                dp[i][remain] = INT_MAX;
                for (int currCoinsNum = 0; currCoinsNum * coins[i] <= remain; ++currCoinsNum) {
                    int followingCoinsNum = dp[i + 1][remain - currCoinsNum * coins[i]];
                    if (followingCoinsNum != INT_MAX) {
                        dp[i][remain] = min(dp[i][remain], currCoinsNum + followingCoinsNum);
                    }
                }
            }
        }

        return dp[0][amount] == INT_MAX ? -1 : dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA^2\right)$

空间复杂度：$O\left(NA\right)$

------

动态规划 2（空间压缩 + 斜率优化）：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<int> dp(amount + 1);

        for (int remain = 1; remain <= amount; ++remain) {
            dp[remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= amount; ++remain) {
                if (remain - coins[i] >= 0 && dp[remain - coins[i]] != INT_MAX) {
                    dp[remain] = min(dp[remain], dp[remain - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(A\right)$

### 零钱兑换（有限制）

题目：同 https://leetcode.cn/problems/gaM7Ch，但 `coins` 中可能有重复值且每个值只能用一次。

暴力递归：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int res = f(coins, 0, amount);
        return res == INT_MAX ? -1 : res;
    }

    int f(vector<int>& coins, int i, int remain) {
        int N = coins.size();
        if (!remain) {
            return 0;
        } else if (i == N) {
            return INT_MAX;
        }

        int p1Next = remain - coins[i] >= 0 ? f(coins, i + 1, remain - coins[i]) : INT_MAX;
        int p2 = f(coins, i + 1, remain);
        return p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划：

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int N = coins.size();
        vector<vector<int>> dp(N + 1, vector<int>(amount + 1));

        for (int remain = 1; remain <= N; ++remain) {
            dp[N][remain] = INT_MAX;
        }

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = 1; remain <= N; ++remain) {
                int p1Next = remain - coins[i] >= 0 ? dp[i + 1][remain - coins[i]] : INT_MAX;
                int p2 = dp[i + 1][remain];
                dp[i][remain] = p1Next == INT_MAX ? p2 : min(p1Next + 1, p2);
            }
        }
        
        return dp[0][amount];
    }
};
```

时间复杂度：$O\left(NA\right)$

空间复杂度：$O\left(NA\right)$

### 目标和

https://leetcode.cn/problems/YaVDxD

该题很容易写出暴力递归 1 所示的代码，但是会发现在改动态规划时 `remain` 的范围并不好判断，所以需要将原问题转化成另一个让可变参数的范围容易判断的问题。该题可以这样转化：

记 `nums` 的元素之和为 $S$，在 `nums` 中的元素前面添加正负号后，记所有前面添加符号的元素之和为 $M$，易得 $target=\left(S-M\right)-M$，即 $M=\left(S-target\right)/2$。现在需要在 `nums` 中找出一些元素使得这些元素之和为 $\left(S-target\right)/2$，求有多少种不同的找法。

暴力递归 1：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        return f(nums, 0, target);
    }

    int f(vector<int>& nums, int i, int remain) {
        int N = nums.size();
        if (i == N) {
            return !remain;
        }

        return f(nums, i + 1, remain + nums[i]) + f(nums, i + 1, remain - nums[i]);
    }
};
```

暴力递归 2：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        return S - target < 0 || (S - target) & 1 ? 0 : f(nums, 0, (S - target) >> 1);
    }

    // remain >= 0
    int f(vector<int>& nums, int i, int remain) {
        int N = nums.size();
        if (i == N) {
            return !remain;
        }

        return (remain - nums[i] >= 0 ? f(nums, i + 1, remain - nums[i]) : 0) + f(nums, i + 1, remain);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        if (S - target < 0 || (S - target) & 1) {
            return 0;
        }

        int M = (S - target) >> 1;
        int N = nums.size();
        vector<vector<int>> dp(N + 1, vector<int>(M + 1));

        dp[N][0] = 1;

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = M; remain >= 0; --remain) {
                dp[i][remain] = (remain - nums[i] >= 0 ? dp[i + 1][remain - nums[i]] : 0) + dp[i + 1][remain];
            }
        }

        return dp[0][M];
    }
};
```

时间复杂度：$O\left(NM\right)$

空间复杂度：$O\left(NM\right)$

------

动态规划 2（空间压缩）：

```
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int S = reduce(nums.begin(), nums.end());
        if (S - target < 0 || (S - target) & 1) {
            return 0;
        }

        int M = (S - target) >> 1;
        int N = nums.size();
        vector<int> dp(M + 1);

        dp[0] = 1;

        for (int i = N - 1; i >= 0; --i) {
            for (int remain = M; remain >= 0; --remain) {
                dp[remain] = (remain - nums[i] >= 0 ? dp[remain - nums[i]] : 0) + dp[remain];
            }
        }

        return dp[M];
    }
};
```

时间复杂度：$O\left(NM\right)$

空间复杂度：$O\left(M\right)$

### 机器人达到指定位置方法数

https://www.nowcoder.com/questionTerminal/54679e44604f44d48d1bcadb1fe6eb61

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

long long f(int N, int M, int K, int P) {
    if (!K) {
        return M == P;
    }

    return ((P > 1 ? f(N, M, K - 1, P - 1) : 0) + (P < N ? f(N, M, K - 1, P + 1) : 0)) % (long long) (1e9 + 7);
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << f(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

long long waysNum(int N, int M, int K, int P) {
    vector<vector<long long>> dp(K + 1, vector<long long>(N + 1));

    dp[0][M] = 1;

    for (int K_ = 1; K_ <= K; ++K_) {
        for (int P_ = 1; P_ <= N; ++P_) {
            dp[K_][P_] = ((P_ > 1 ? dp[K_ - 1][P_ - 1] : 0) + (P_ < N ? dp[K_ - 1][P_ + 1] : 0)) % (long long) (1e9 + 7);
        }
    }

    return dp[K][P];
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << waysNum(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(KN\right)$

空间复杂度：$O\left(KN\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

long long waysNum(int N, int M, int K, int P) {
    vector<long long> dp(N + 1);

    dp[M] = 1;

    for (int K_ = 1; K_ <= K; ++K_) {
        int temp1 = -1;
        int temp2 = -1;
        for (int P_ = 1; P_ <= N; ++P_) {
            temp2 = dp[P_];
            dp[P_] = ((P_ > 1 ? temp1 : 0) + (P_ < N ? dp[P_ + 1] : 0)) % (long long) (1e9 + 7);
            temp1 = temp2;
        }
    }

    return dp[P];
}

int main() {
    int N;
    int M;
    int K;
    int P;
    while (cin >> N >> M >> K >> P) {
        cout << waysNum(N, M, K, P) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(KN\right)$

空间复杂度：$O\left(N\right)$

### 最小路径和

https://leetcode.cn/problems/minimum-path-sum

暴力递归：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        return f(grid, 0, 0);
    }

    int f(vector<vector<int>>& grid, int i, int j) {
        int M = grid.size();
        int N = grid[0].size();
        if (i == M - 1 && j == N - 1) {
            return grid[i][j];
        }

        return grid[i][j] + min(i < M - 1 ? f(grid, i + 1, j) : INT_MAX, j < N - 1 ? f(grid, i, j + 1) : INT_MAX);
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int M = grid.size();
        int N = grid[0].size();
        vector<vector<int>> dp(M, vector<int>(N));

        dp[M - 1][N - 1] = grid[M - 1][N - 1];
        for (int i = M - 2; i >= 0; --i) {
            dp[i][N - 1] = grid[i][N - 1] + dp[i + 1][N - 1];
        }
        for (int j = N - 2; j >= 0; --j) {
            dp[M - 1][j] = grid[M - 1][j] + dp[M - 1][j + 1];
        }

        for (int i = M - 2; i >= 0; --i) {
            for (int j = N - 2; j >= 0; --j) {
                dp[i][j] = grid[i][j] + min(dp[i + 1][j], dp[i][j + 1]);
            }
        }
        
        return dp[0][0];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(MN\right)$

------

动态规划 2：

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int M = grid.size();
        int N = grid[0].size();
        vector<int> dp(N);

        dp[N - 1] = grid[M - 1][N - 1];
        for (int j = N - 2; j >= 0; --j) {
            dp[j] = grid[M - 1][j] + dp[j + 1];
        }

        for (int i = M - 2; i >= 0; --i) {
            dp[N - 1] = grid[i][N - 1] + dp[N - 1];
            for (int j = N - 2; j >= 0; --j) {
                dp[j] = grid[i][j] + min(dp[j], dp[j + 1]);
            }
        }

        return dp[0];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(N\right)$

### 最长公共子串

https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602

暴力递归：

```c++
class LongestSubstring {
public:
    int findLongest(string str1, int M, string str2, int N) {
        int res = 0;
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                res = max(res, f(str1, M, str2, N, i, j));
            }
        }
        return res;
    }

    int f(string& str1, int M, string& str2, int N, int i, int j) {
        if (!i || !j) {
            return str1[i] == str2[j];
        }

        return str1[i] == str2[j] ? 1 + f(str1, M, str2, N, i - 1, j - 1) : 0;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class LongestSubstring {
public:
    int findLongest(string str1, int M, string str2, int N) {
        vector<vector<int>> dp(M, vector<int>(N));
        int res = 0;

        for (int i = 0; i < M; ++i) {
            dp[i][0] = str1[i] == str2[0];
            res = max(res, dp[i][0]);
        }
        for (int j = 1; j < N; ++j) {
            dp[0][j] = str1[0] == str2[j];
            res = max(res, dp[0][j]);
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                dp[i][j] = str1[i] == str2[j] ? 1 + dp[i - 1][j - 1] : 0;
                res = max(res, dp[i][j]);
            }
        }

        return res;
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(MN\right)$

------

动态规划 2（空间压缩）：

```c++
class LongestSubstring {
public:
    int findLongest(string str1, int M, string str2, int N) {
        vector<int> dp(N);
        int res = 0;

        for (int j = 0; j < N; ++j) {
            dp[j] = str1[0] == str2[j];
            res = max(res, dp[j]);
        }

        for (int i = 1; i < M; ++i) {
            int temp1 = dp[0];
            dp[0] = str1[i] == str2[0];
            res = max(res, dp[0]);
            for (int j = 1; j < N; ++j) {
                int temp2 = dp[j];
                dp[j] = str1[i] == str2[j] ? 1 + temp1 : 0;
                res = max(res, dp[j]);
                temp1 = temp2;
            }
        }

        return res;
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 3（空间压缩）：

求二维表中的最大值，不需要真正把整张二维表都表示出来，我们只需要让二维表中的每个值都出现一次并记录下最大值就行了。

填表顺序如下：

<img src="刷题笔记.assets/image-20230921203809766.png" alt="image-20230921203809766" style="zoom:33%;" />

```c++
class LongestSubstring {
public:
    int findLongest(string str1, int M, string str2, int N) {
        int row = 0;
        int col = N - 1;
        int res = 0;

        while (row < M) {
            int i = row;
            int j = col;
            int prev = 0;

            if (!i) {
                prev = str1[0] == str2[j];
                res = max(res, prev);
            } else if (!j) {
                prev = str1[i] == str2[0];
                res = max(res, prev);
            }
            ++i;
            ++j;

            while (i < M && j < N) {
                prev = str1[i] == str2[j] ? 1 + prev : 0;
                res = max(res, prev);
                ++i;
                ++j;
            }

            col ? --col : ++row;
        }

        return res;
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(1\right)$

------

动态规划 4（空间压缩，同动态规划 3，只是换了一种写法）：

```c++
class LongestSubstring {
public:
    int findLongest(string str1, int M, string str2, int N) {
        int row = 0;
        int col = N - 1;
        int res = 0;

        while (row < M) {
            int i = row;
            int j = col;
            int len = 0;

            while (i < M && j < N) {
                if (str1[i] == str2[j]) {
                    res = max(res, ++len);
                } else {
                    len = 0;
                }
                ++i;
                ++j;
            }

            col ? --col : ++row;
        }

        return res;
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(1\right)$

### 最长公共子序列

https://leetcode.cn/problems/longest-common-subsequence

`dp[i][j]` 表示 `str1[0...i]` 和 `str2[0...j]` 上的最长公共子序列的长度。

算 `dp[i][j]` 时这样分类：

1. `str1[i]` 不是最长公共子序列的一部分，这时 `dp[i][j] = dp[i - 1][j]`；
2. `str2[j]` 不是最长公共子序列的一部分，这时 `dp[i][j] = dp[i][j - 1]`；
3. `str1[i]` 和 `str2[j]` 都是最长公共子序列的一部分（要求 `str1[i] == str2[j]`），这时 `dp[i][j] = dp[i - 1][j - 1] + 1`；

暴力递归：

```c++
class Solution {
public:
    int longestCommonSubsequence(string str1, string str2) {
        int M = str1.size();
        int N = str2.size();
        return f(str1, str2, M - 1, N - 1);
    }

    int f(string& str1, string& str2, int i, int j) {
        if (!i && !j) {
            return str1[0] == str2[0];
        } else if (!i) {
            return str1[0] == str2[j] ? 1 : f(str1, str2, 0, j - 1);
        } else if (!j) {
            return str1[i] == str2[0] ? 1 : f(str1, str2, i - 1, 0);
        }

        int res = max(f(str1, str2, i, j - 1), f(str1, str2, i - 1, j));
        if (str1[i] == str2[j]) {
            res = max(res, f(str1, str2, i - 1, j - 1) + 1);
        }
        return res;
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    int longestCommonSubsequence(string str1, string str2) {
        int M = str1.size();
        int N = str2.size();
        vector<vector<int>> dp(M, vector<int>(N));

        dp[0][0] = str1[0] == str2[0];
        for (int i = 1; i < M; ++i) {
            dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
        }
        for (int j = 1; j < N; ++j) {
            dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
        }

        for (int i = 1; i < M; ++i) {
            for (int j = 1; j < N; ++j) {
                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                if (str1[i] == str2[j]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }

        return dp[M - 1][N - 1];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(MN\right)$

------

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int longestCommonSubsequence(string str1, string str2) {
        int M = str1.size();
        int N = str2.size();
        vector<int> dp(N);

        dp[0] = str1[0] == str2[0];
        for (int j = 1; j < N; ++j) {
            dp[j] = str1[0] == str2[j] ? 1 : dp[j - 1];
        }

        for (int i = 1; i < M; ++i) {
            int temp1 = dp[0];
            dp[0] = str1[i] == str2[0] ? 1 : dp[0];
            for (int j = 1; j < N; ++j) {
                int temp2 = dp[j];
                dp[j] = max(dp[j - 1], dp[j]);
                if (str1[i] == str2[j]) {
                    dp[j] = max(dp[j], temp1 + 1);
                }
                temp1 = temp2;
            }
        }

        return dp[N - 1];
    }
};
```

时间复杂度：$O\left(MN\right)$

空间复杂度：$O\left(N\right)$

### 最长回文子序列

https://leetcode.cn/problems/longest-palindromic-subsequence

最长公共子序列的变式：

```c++
class Solution {
public:
    int longestPalindromeSubseq(string str) {
        string strReversed = str;
        reverse(str.begin(), str.end());
        return longestCommonSubsequence(str, strReversed);
    }

    int longestCommonSubsequence(string str1, string str2) {
        int M = str1.size();
        int N = str2.size();
        vector<int> dp(N);

        dp[0] = str1[0] == str2[0];
        for (int j = 1; j < N; ++j) {
            dp[j] = str1[0] == str2[j] ? 1 : dp[j - 1];
        }

        for (int i = 1; i < M; ++i) {
            int temp1 = dp[0];
            dp[0] = str1[i] == str2[0] ? 1 : dp[0];
            for (int j = 1; j < N; ++j) {
                int temp2 = dp[j];
                dp[j] = max(dp[j - 1], dp[j]);
                if (str1[i] == str2[j]) {
                    dp[j] = max(dp[j], temp1 + 1);
                }
                temp1 = temp2;
            }
        }

        return dp[N - 1];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

暴力递归：

```c++
class Solution {
public:
    int longestPalindromeSubseq(string str) {
        int N = str.size();
        return f(str, 0, N - 1);
    }

    int f(string& str, int i, int j) {
        if (i == j) {
            return 1;
        } else if (i > j) {
            return 0;
        }

        int res = max(f(str, i + 1, j), f(str, i, j - 1));
        if (str[i] == str[j]) {
            res = max(res, f(str, i + 1, j - 1) + 2);  // 这里可能出现 i + 1 > j - 1 的情况
        }
        return res;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

动态规划：

```c++
class Solution {
public:
    int longestPalindromeSubseq(string str) {
        int N = str.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = 1;
        }

        for (int i = N - 2; i >= 0; --i) {
            for (int j = i + 1; j < N; ++j) {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                if (str[i] == str[j]) {
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2);
                }
            }
        }

        return dp[0][N - 1];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

动态规划 2（空间压缩）：

```c++
class Solution {
public:
    int longestPalindromeSubseq(string str) {
        int N = str.size();
        vector<int> dp(N);

        dp[N - 1] = 1;

        for (int i = N - 2; i >= 0; --i) {
            int temp1 = 0;
            dp[i] = 1;
            for (int j = i + 1; j < N; ++j) {
                int temp2 = dp[j];
                dp[j] = max(temp2, dp[j - 1]);
                if (str[i] == str[j]) {
                    dp[j] = max(dp[j], temp1 + 2);
                }
                temp1 = temp2;
            }
        }

        return dp[N - 1];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

### Bob 的生存概率

https://www.nowcoder.com/questionTerminal/be311584a3d64ee0a7462dbeb79f00f5

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

long long f(int M, int N, int i, int j, int k) {
    if (i < 0 || i > M - 1 || j < 0 || j > N - 1) {
        return 0;
    } else if (!k) {
        return 1;
    }

    return f(M, N, i - 1, j, k - 1) + f(M, N, i + 1, j, k - 1) + f(M, N, i, j - 1, k - 1) + f(M, N, i, j + 1, k - 1);
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = f(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

long long getSurvivalWaysNum(int M, int N, int i, int j, int k) {
    vector<vector<vector<long long>>> dp(M, vector<vector<long long>>(N, vector<long long>(k + 1)));

    for (int i_ = 0; i_ < M; ++i_) {
        for (int j_ = 0; j_ < N; ++j_) {
            dp[i_][j_][0] = 1;
        }
    }

    auto getValue = [&dp](int i_, int j_, int k_) -> long long {
        int M = dp.size();
        int N = dp[0].size();
        return i_ < 0 || i_ > M - 1 || j_ < 0 || j_ > N - 1 ? 0 : dp[i_][j_][k_];
    };
    for (int k_ = 1; k_ <= k; ++k_) {
        for (int i_ = 0; i_ < M; ++i_) {
            for (int j_ = 0; j_ < N; ++j_) {
                dp[i_][j_][k_] = getValue(i_ - 1, j_, k_ - 1) + getValue(i_ + 1, j_, k_ - 1) + getValue(i_, j_ - 1, k_ - 1) + getValue(i_, j_ + 1, k_ - 1);
            }
        }
    }
    return dp[i][j][k];
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = getSurvivalWaysNum(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(MNk\right)$

空间复杂度：$O\left(MNk\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

long long getSurvivalWaysNum(int M, int N, int i, int j, int k) {
    vector<vector<long long>> dp(M, vector<long long>(N, 1));

    for (int k_ = 1; k_ <= k; ++k_) {
        vector<long long> temp1(N);
        vector<long long> temp2(N);
        for (int i_ = 0; i_ < M; ++i_) {
            temp2 = dp[i_];
            for (int j_ = 0; j_ < N; ++j_) {
                dp[i_][j_] = (i_ > 0 ? temp1[j_] : 0) + (i_ < M - 1 ? dp[i_ + 1][j_] : 0) + (j_ > 0 ? temp2[j_ - 1] : 0) + (j_ < N - 1 ? dp[i_][j_ + 1] : 0);
            }
            temp1 = temp2;
        }
    }
    return dp[i][j];
}

string survivalProbability(int M, int N, int i, int j, int k) {
    long long totalWaysNum = pow(4, k);
    long long survivalWaysNum = getSurvivalWaysNum(M, N, i, j, k);
    long long gcdVal = gcd(survivalWaysNum, totalWaysNum);
    return to_string(survivalWaysNum / gcdVal) + "/" + to_string(totalWaysNum / gcdVal);
}

int main() {
    int M;
    int N;
    int i;
    int j;
    int k;
    while (cin >> M >> N >> i >> j >> k) {
        cout << survivalProbability(M, N, i, j, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(MNk\right)$

空间复杂度：$O\left(MN\right)$

### 跳马

https://www.nowcoder.com/questionTerminal/c45704a41617402fb5c34a1778bb2645

暴力递归：

递归函数直接对前一步的位置进行分类的话可以不用在递归函数的参数列表中传入当前位置，这样会使得递归函数的入参更少。

```c++
#include <bits/stdc++.h>

using namespace std;

int waysNum(int x, int y, int k) {
    if (x < 0 || x > 8 || y < 0 || y > 9) {
        return 0;
    }
    if (!k) {
        return !x && !y;
    }

    return waysNum(x + 2, y + 1, k - 1) + waysNum(x + 2, y - 1, k - 1) + waysNum(x - 2, y + 1, k - 1) + waysNum(x - 2, y - 1, k - 1) + waysNum(x + 1, y + 2, k - 1) + waysNum(x + 1, y - 2, k - 1) + waysNum(x - 1, y + 2, k - 1) + waysNum(x - 1, y - 2, k - 1);
}

int main() {
    int x;
    int y;
    int k;
    while (cin >> x >> y >> k) {
        cout << waysNum(x, y, k) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

int getVal(vector<vector<vector<int>>>& dp, int x_, int y_, int k_) {
    if (x_ < 0 || x_ > 8 || y_ < 0 || y_ > 9) {
        return 0;
    }

    return dp[x_][y_][k_];
}

int waysNum(int x, int y, int k) {
    vector<vector<vector<int>>> dp(9, vector<vector<int>>(10, vector<int>(k + 1)));

    dp[0][0][0] = 1;

    for (int k_ = 1; k_ <= k; ++k_) {
        for (int x_ = 0; x_ < 9; ++x_) {
            for (int y_ = 0; y_ < 10; ++y_) {
                dp[x_][y_][k_] = getVal(dp, x_ - 1, y_ + 2, k_ - 1) + getVal(dp, x_ + 1, y_ + 2, k_ - 1) + getVal(dp, x_ - 2, y_ + 1, k_ - 1) + getVal(dp, x_ + 2, y_ + 1, k_ - 1) + getVal(dp, x_ - 2, y_ - 1, k_ - 1) + getVal(dp, x_ + 2, y_ - 1, k_ - 1) + getVal(dp, x_ - 1, y_ - 2, k_ - 1) + getVal(dp, x_ + 1, y_ - 2, k_ - 1);
            }
        }
    }

    return dp[x][y][k];
}

int main() {
    int x;
    int y;
    int k;
    while (cin >> x >> y >> k) {
        cout << waysNum(x, y, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(k\right)$

空间复杂度：$O\left(k\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

int getVal(vector<vector<int>>& temp, int x_, int y_) {
    if (x_ < 0 || x_ > 8 || y_ < 0 || y_ > 9) {
        return 0;
    }

    return temp[x_][y_];
}

int waysNum(int x, int y, int k) {
    vector<vector<int>> dp(9, vector<int>(10));

    dp[0][0] = 1;

    for (int k_ = 1; k_ <= k; ++k_) {
        vector<vector<int>> temp = dp;
        for (int x_ = 0; x_ < 9; ++x_) {
            for (int y_ = 0; y_ < 10; ++y_) {
                dp[x_][y_] = getVal(temp, x_ - 1, y_ + 2) + getVal(temp, x_ + 1, y_ + 2) + getVal(temp, x_ - 2, y_ + 1) + getVal(temp, x_ + 2, y_ + 1) + getVal(temp, x_ - 2, y_ - 1) + getVal(temp, x_ + 2, y_ - 1) + getVal(temp, x_ - 1, y_ - 2) + getVal(temp, x_ + 1, y_ - 2);
            }
        }
    }

    return dp[x][y];
}

int main() {
    int x;
    int y;
    int k;
    while (cin >> x >> y >> k) {
        cout << waysNum(x, y, k) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(k\right)$

空间复杂度：$O\left(1\right)$

### 序列

https://noobdream.com/DreamJudge/Issue/page/995

暴力递归：

```c++
#include <bits/stdc++.h>

using namespace std;

// 0 < i <= N
int f(vector<int>& A, int i, int prev) {
    int N = A.size();
    if (i == N) {
        return 0;
    }

    int followingWeight = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        followingWeight = min(followingWeight, abs(A[i] - num) + (num - prev) * (num - prev) + f(A, i + 1, num));
    }
    return followingWeight;
}

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + f(A, 1, num));
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
#include <bits/stdc++.h>

using namespace std;

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    vector<vector<int>> dp(N + 1, vector<int>(10));

    for (int i = N - 1; i > 0; --i) {
        for (int prev = 0; prev < 10; ++prev) {
            dp[i][prev] = INT_MAX;
            for (int num = 0; num < 10; ++num) {
                dp[i][prev] = min(dp[i][prev], abs(A[i] - num) + (num - prev) * (num - prev) + dp[i + 1][num]);
            }
        }
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + dp[1][num]);
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划 2（空间压缩）：

```c++
#include <bits/stdc++.h>

using namespace std;

int minWeight(vector<int>& A) {
    int N = A.size();
    if (N == 1) {
        return 0;
    }

    vector<int> dp(10);

    for (int i = N - 1; i > 0; --i) {
        vector<int> temp = dp;
        for (int prev = 0; prev < 10; ++prev) {
            dp[prev] = INT_MAX;
            for (int num = 0; num < 10; ++num) {
                dp[prev] = min(dp[prev], abs(A[i] - num) + (num - prev) * (num - prev) + temp[num]);
            }
        }
    }

    int res = INT_MAX;
    for (int num = 0; num < 10; ++num) {
        res = min(res, abs(A[0] - num) + dp[num]);
    }
    return res;
}

int main() {
    int N;
    while (cin >> N) {
        vector<int> A(N);
        for (int& num: A) {
            cin >> num;
        }

        cout << minWeight(A) << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(N\right)$

空间复杂度：$O\left(1\right)$

### 预测赢家

https://leetcode.cn/problems/predict-the-winner

这个题目如果要改动态规划的话，需要一个表 `fdp` 和一个表 `sdp`，因为每个表记录的是一个递归函数在确定的可变参数下的取值，现在有两个递归函数，所以需要两个表。假设 `L` 表示行，`R` 表示列，因为 `L <= R`，所以两个表的左下部分是不会被使用的（但是对角线是可以使用的）。

暴力递归 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= s(nums, 0, N - 1);
    }

    // 如果我是先手，我能获得的最大分数
    int f(vector<int>& arr, int L, int R) {
        if (L == R) {
            return arr[L];
        }

        // 我拿左端和右端两种情况，取max
        return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
    }

    // 如果我是后手，我能获得的最大分数
    int s(vector<int>& arr, int L, int R) {
        if (L == R) {
            return 0;
        }

        // 这一步是对手决定的，对手肯定是选择一个对我最不利的拿法，所以取min，所以分对手拿左端和右端两种情况
        return min(f(arr, L + 1, R), f(arr, L, R - 1));
    }
};
```

也可以只用一个递归函数实现。

暴力递归 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= 0;
    }

    // 如果返回的是负数，那么这个负数的绝对值表示对手的得分
    int f(vector<int>& nums, int L, int R) {
        if (L == R) {
            return nums[L];
        }

        return max(nums[L] - f(nums, L + 1, R), nums[R] - f(nums, L, R - 1));
    }
};
```

时间复杂度：

空间复杂度：

------

动态规划 1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
            }
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划 3：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> dp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            dp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                dp[L][R] = max(nums[L] - dp[L + 1][R], nums[R] - dp[L][R - 1]);
            }
        }

        return dp[0][N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

------

动态规划 4（空间压缩）：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N);

        for (int L = N - 1; L >= 0; --L) {
            dp[L] = nums[L];
            for (int R = L + 1; R < N; ++R) {
                dp[R] = max(nums[L] - dp[R], nums[R] - dp[R - 1]);
            }
        }

        return dp[N - 1] >= 0;
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

# 数学

## 题目

### 分数累加（浙大）

题目：
$$
\frac{1}{a}=\frac{1}{n_1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
其中 $n_1$ 至 $n_m$ 单调递增，例如 $a=2,m=2$ 时，$\frac{1}{2}=\frac{1}{3}+\frac{1}{6}$，现给定 $a$ 和 $m$，任意求一组解。

注：假设所有的解都能用 `int` 类型表示。

解答：

令 $n_1=a+1$，则：
$$
\frac{1}{a}=\frac{1}{a+1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}\\
\frac{1}{a\left(a+1\right)}=\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
很明显，这时可以进行迭代求解了。迭代到最后等式右边只有 $n_m$ 这一项：
$$
\frac{1}{a'}=\frac{1}{n_m}
$$
此时 $n_m=a'$。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int a;
    int m;
    while (cin >> a >> m) {
        int nx = a + 1;
        cout << nx;

        for (int i = 2; i < m; ++i) {
            nx = (nx - 1) * nx + 1;
            cout << ' ' << nx;
        }

        nx = (nx - 1) * nx;
        cout << ' ' << nx << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

