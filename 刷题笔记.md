# 动态规划

### 预测赢家

https://leetcode.cn/problems/predict-the-winner

这个题目如果要改动态规划的话，需要一个表 `fdp` 和一个表 `sdp`，因为每个表记录的是一个递归函数在确定的可变参数下的取值，现在有两个递归函数，所以需要两个表。假设 `L` 表示行，`R` 表示列，因为 `L <= R`，所以两个表的左下部分是不会被使用的（但是对角线是可以使用的）。

递归：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        return f(nums, 0, N - 1) >= s(nums, 0, N - 1);
    }

    // 如果我是先手，我能获得的最大分数
    int f(vector<int>& arr, int L, int R) {
        if (L == R) {
            return arr[L];
        }

        // 我拿左端和右端两种情况，取max
        return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
    }

    // 如果我是后手，我能获得的最大分数
    int s(vector<int>& arr, int L, int R) {
        if (L == R) {
            return 0;
        }

        // 这一步是对手决定的，对手肯定是选择一个对我最不利的拿法，所以取min，所以分对手拿左端和右端两种情况
        return min(f(arr, L + 1, R), f(arr, L, R - 1));
    }
};
```

时间复杂度：$O\left(2^N\right)$

空间复杂度：$O\left(N\right)$

------

动态规划1：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        for (int L = N - 2; L >= 0; --L) {
            for (int R = L + 1; R < N; ++R) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
            }
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

动态规划2：

```c++
class Solution {
public:
    bool predictTheWinner(vector<int>& nums) {
        int N = nums.size();
        vector<vector<int>> fdp(N, vector<int>(N));
        vector<vector<int>> sdp(N, vector<int>(N));

        for (int i = 0; i < N; ++i) {
            fdp[i][i] = nums[i];
        }

        int slash = 1;
        while (slash < N) {
            int L = 0;
            int R = slash;
            while (R < N) {
                fdp[L][R] = max(nums[L] + sdp[L + 1][R], nums[R] + sdp[L][R - 1]);
                sdp[L][R] = min(fdp[L + 1][R], fdp[L][R - 1]);
                ++L;
                ++R;
            }
            ++slash;
        }

        return fdp[0][N - 1] >= sdp[0][N - 1];
    }
};
```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N^2\right)$

------

动态规划3（空间压缩）：

```c++

```

时间复杂度：$O\left(N^2\right)$

空间复杂度：$O\left(N\right)$

# 数学

### 分数累加（浙大）

题目：
$$
\frac{1}{a}=\frac{1}{n_1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
其中 $n_1$ 至 $n_m$ 单调递增，例如 $a=2,m=2$ 时，$\frac{1}{2}=\frac{1}{3}+\frac{1}{6}$，现给定 $a$ 和 $m$，任意求一组解。

注：假设所有的解都能用 `int` 类型表示。

解答：

令 $n_1=a+1$，则：
$$
\frac{1}{a}=\frac{1}{a+1}+\frac{1}{n_2}+\cdots+\frac{1}{n_m}\\
\frac{1}{a\left(a+1\right)}=\frac{1}{n_2}+\cdots+\frac{1}{n_m}
$$
很明显，这时可以进行迭代求解了。迭代到最后等式右边只有 $n_m$ 这一项：
$$
\frac{1}{a'}=\frac{1}{n_m}
$$
此时 $n_m=a'$。

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    int a;
    int m;
    while (cin >> a >> m) {
        int nx = a + 1;
        cout << nx;

        for (int i = 2; i < m; ++i) {
            nx = (nx - 1) * nx + 1;
            cout << ' ' << nx;
        }

        nx = (nx - 1) * nx;
        cout << ' ' << nx << endl;
    }

    return 0;
}
```

时间复杂度：$O\left(m\right)$

空间复杂度：$O\left(1\right)$

